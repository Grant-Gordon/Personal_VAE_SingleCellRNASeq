# generate_config_hpp.py
# AI-Acknowledgement: Large sections of this file were generated by ChatGPT
import yaml
import re
from supported_types import SUPPORTED_OBJECTS


def load_yaml(path: str) -> dict:
    with open(path, 'r') as f:
        return yaml.safe_load(f)


def interpolate_placeholders(config: dict, external_context: dict = None) -> dict:
    external_context = external_context or {}

    def resolve_path(path: str, context):
        keys = path.split('.')
        val = context
        for k in keys:
            if isinstance(val, dict) and k in val:
                val = val[k]
            else:
                raise KeyError(f"Placeholder {{{path}}} could not be resolved - key '{k}' not found at path '{'.'.join(keys[:keys.index(k)])}'")
        return val

    def resolve(value, context):
        if isinstance(value, str):
            def replace(m):
                key = m.group(1)
                if key in external_context:
                    return str(external_context[key])
                return str(resolve_path(key, context))
            return re.sub(r"{([^}]+)}", replace, value)
        elif isinstance(value, list):
            return [resolve(v, context) for v in value]
        elif isinstance(value, dict):
            return {k: resolve(v, context) for k, v in value.items()}
        return value

    return resolve(config, config)

def merge_external_into_config(config: dict, external: dict):
    for dotted_key, value in external.items():
        keys = dotted_key.split(".")
        node = config
        for k in keys[:-1]:
            node = node.setdefault(k, {})
        node[keys[-1]] = value

def flatten_config(d: dict, prefix: str = "") -> dict:
    flat = {}
    for k, v in d.items():
        if isinstance(v, dict) and v.get("construct") not in (None, "false"):
            continue  # handled elsewhere
        new_prefix = f"{prefix}.{k}" if prefix else k
        if isinstance(v, dict):
            flat.update(flatten_config(v, new_prefix))
        else:
            flat[new_prefix] = v
    return flat

def to_camel_case(s: str) -> str:
    return ''.join(part.capitalize() for part in s.split('_'))

def format_cpp_identifier(key: str) -> str:
    parts = key.split('.')
    if len(parts) < 2:
        raise ValueError(f"Expected at least one hierarchy level in key: {key}")

    *hierarchy, leaf = parts
    camel_prefix = '_'.join(to_camel_case(p) for p in hierarchy)
    return f"{camel_prefix}__{leaf}"

def format_constructor_identifier(path: list) -> str:
    *hierarchy, leaf = path
    camel = '_'.join(to_camel_case(part) for part in hierarchy)
    return f"{camel}__{leaf}"

def generate_scalar_lines(flat_config: dict) -> list:
    lines = []
    entries = []
    for key, val in flat_config.items():
        cpp_key = format_cpp_identifier(key)

        if isinstance(val, bool):
            cpp_type = "constexpr bool"
            cpp_val = "true" if val else "false"
        elif isinstance(val, int):
            cpp_type = "constexpr int"
            cpp_val = str(val)
        elif isinstance(val, float):
            cpp_type = "constexpr float"
            cpp_val = str(val)
        elif isinstance(val, str):
            cpp_type = "constexpr std::string_view"
            cpp_val = f'"{val}"'
        else:
            raise ValueError(f"Unsupported type: {key} = {val}")

        entries.append((cpp_type, cpp_key, cpp_val))

    type_width = max(len(e[0]) for e in entries)
    for cpp_type, cpp_key, cpp_val in entries:
        lines.append(f"{cpp_type.ljust(type_width)} {cpp_key} = {cpp_val};")
    return lines

def generate_layers_vector(identifier: str, architecture: list) -> list:
    lines = [
        "template <typename Scalar>",
        f"constexpr std::array<std::shared_ptr<Layer<Scalar>>, {len(architecture)}> {identifier} = {{"
    ]
    for layer in architecture:
        if not isinstance(layer, dict) or len(layer) != 1:
            raise ValueError(f"Invalid layer entry: {layer}")
        layer_type, args = list(layer.items())[0]
        args_str = ", ".join(map(str, args))
        lines.append(f"    std::make_shared<{layer_type}Layer<Scalar>>({args_str}),")
    lines.append("};")
    return lines

def find_and_generate_constructs(d: dict, path: list, out_lines: list):
    for k, v in d.items():
        if not isinstance(v, dict):
            continue

        construct_mode = v.get("construct")
        identifier = format_constructor_identifier(path + [k])

        if construct_mode == "object":
            obj_type = v["type"]
            if obj_type not in SUPPORTED_OBJECTS:
                raise ValueError(f"Unsupported object type '{obj_type}' at {'.'.join(path + [k])}")
            arg_keys = SUPPORTED_OBJECTS[obj_type]
            args = [v[arg] for arg in arg_keys]
            out_lines.extend([
                f"template <typename Scalar>",
                f"constexpr {obj_type}<Scalar> {identifier} = {obj_type}<Scalar>({', '.join(map(str, args))});",
                ""
            ])

        elif construct_mode == "architecture":
            if "layers" not in v:
                raise ValueError(f"Expected 'layers' key in architecture block at {'.'.join(path + [k])}")
            out_lines.extend(generate_layers_vector(identifier, v["layers"]))

        elif construct_mode == "false":
            # Do nothing â€” these keys are flattened as constexpr scalars
            continue

        else:
            # recurse into nested dicts
            find_and_generate_constructs(v, path + [k], out_lines)


def write_config_header(yaml_path: str, output_path: str = "config.h", external_context: dict = None):
    config = load_yaml(yaml_path)
    config = interpolate_placeholders(config, external_context)
    merge_external_into_config(config, external_context)
    flat_config = flatten_config(config)

    scalar_lines = generate_scalar_lines(flat_config)

    constructed_lines = []
    find_and_generate_constructs(config, [], constructed_lines)


    full_lines = [
        "#pragma once",
        "#include <string_view>",
        "#include <memory>",
        "#include <array>",
        "#include \"Layers/LinearLayer.hpp\"",
        "#include \"Layers/ReLULayer.hpp\"",
        "#include \"param_init_util.h\"",
        "",
        "namespace config {",
        *scalar_lines,
        "",
        *constructed_lines,
    
        "}"  # namespace
    ]

    with open(output_path, "w") as f:
        f.write("\n".join(full_lines))


if __name__ == "__main__":
    write_config_header("example_config.yaml", "example_config.h", external_context={"data.num_features": 1000})
